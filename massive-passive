#!/usr/bin/python2.6
# -*- coding: utf-8 -*-

__author__ = 'Robin Wittler'
__contact__ = 'r.wittler@mysportgroup.de'
__copyright__ = '(c) 2012 by mysportgroup GmbH'
__license__ = 'GPL3+'
__version__ = '0.2.1'

import os
import sys
import signal
import logging
from time import sleep
from Queue import Queue
from mplib import getopts
from threading import Event
from mplib.config import ConfigDir
from mplib.daemon import daemonize
from setproctitle import setproctitle
from mplib.threads import SendNscaWorker
from logging.handlers import SysLogHandler
from mplib.scheduler import MassivePassiveScheduler


BASE_FORMAT_SYSLOG = (
    '%(name)s.%(funcName)s[PID: %(process)d | lineno: %(lineno)d] ' +
    '%(levelname)s: %(message)s'
)

BASE_FORMAT_STDOUT = '%(asctime)s ' + BASE_FORMAT_SYSLOG


class Main(object):
    def __init__(self, name, options, send_worker, scheduler):
        super(Main, self).__init__()
        self.name = name
        self.logger = logging.getLogger(
            '%s.%s' %(
                self.name,
                self.__class__.__name__
            )
        )
        self.options = options
        self.stop_event = Event()
        self.send_queue = Queue()
        self._send_worker = send_worker
        self.send_worker = self._send_worker(
            self.send_queue,
            self.stop_event,
            max_wait=self.options.batch_wait_time,
            batch_mode=self.options.batch_mode
        )
        self._scheduler = scheduler
        self.scheduler = self._scheduler(self.send_queue)

    def run(self):
        self.set_proc_title()
        self.drop_rights()
        if self.options.foreground is False:
            self.write_pidfile()
        self.logger.info('Startup!')
        self.start_send_worker()
        self.add_jobs_to_scheduler()
        self.start_scheduler()
        while not self.stop_event.is_set():
            sleep(0.1)

    def set_proc_title(self):
        setproctitle(
            '%s %s' %(os.path.basename(sys.argv[0]), ' '.join(sys.argv[1:]))
        )

    def write_pidfile(self):
        pid = os.getpid()
        pidfile_fd = os.open(
            self.options.pidfile,
            os.O_CREAT | os.O_EXCL | os.O_RDWR,
            0640
        )
        pidfile = os.fdopen(pidfile_fd, 'w+')
        pidfile.write('%s\n' %(pid,))
        pidfile.flush()
        os.close(pidfile_fd)

    def drop_rights(self):
        current_uid = os.getuid()
        current_gid = os.getgid()

        if not options.group == current_gid:
            self.logger.debug('Switching group to %r', options.group)
            os.setgid(options.group)
            os.setegid(options.group)

        if not options.user == current_uid:
            self.logger.debug('Switching user to %r', options.user)
            os.setuid(options.user)
            os.seteuid(options.user)

    def start(self):
        try:
            self.run()
        except Exception as error:
            self.logger.exception(error)
            self.logger.info('Emitting stop signal ...')
            os.kill(os.getpid(), signal.SIGTERM)

    def start_scheduler(self):
        self.logger.debug('Calling scheduler start ...')
        self.scheduler.start()
        self.logger.debug('Scheduler is running: %r.', self.scheduler.running)

    def add_jobs_to_scheduler(self):
        self.logger.debug('Getting passive check configs ...')
        configs = self.get_check_configs()
        self.scheduler.add_passive_checks(configs)

    def start_send_worker(self):
        self.logger.debug('Calling send_worker thread start ...')
        self.send_worker.start()
        self.logger.debug('send_worker is alive: %r', self.send_worker.is_alive())

    def stop_scheduler(self):
        if self.scheduler.running:
            self.logger.debug('Calling scheduler shutdown ...')
            self.scheduler.shutdown()
            self.logger.debug('Scheduler shutdown done.')
        self.logger.debug('Scheduler is running: %r.', self.scheduler.running)

    def stop_send_worker(self):
        if self.send_worker.is_alive():
            self.logger.debug('Calling send_worker thread join ...')
            self.send_worker.join()
            self.logger.debug('send_worker joined.')
        self.logger.debug('send_worker is alive: %r', self.send_worker.is_alive())

    def get_check_configs(self):
        configs = ConfigDir(self.options.confdir)
        self.logger.debug('Get this from confdir %r: %r', self.options.confdir, configs)
        return configs

    def config_reload(self, signum, sigframe):
        self.logger.info('Received Signal %s ... reloading config now ...', signum)
        self.stop_scheduler()
        self.scheduler = self._scheduler(self.send_queue)
        self.add_jobs_to_scheduler()
        self.start_scheduler()
        self.logger.info('Config reload done.')

    def shutdown(self, signum, sigframe):
        self.logger.info('Received Signal %s.', signum)
        self.logger.info('Going down now ...')
        self.stop_event.set()
        self.logger.debug('Stop Event set.')
        self.stop_scheduler()
        self.stop_send_worker()

        if self.options.foreground is False:
            self.logger.debug('Removing pidfile at %r', self.options.pidfile)
            try:
                os.unlink(self.options.pidfile)
            except OSError as error:
                self.logger.debug('Ignoring error while unlinking pidfile.')
                self.logger.exception(error)
        self.logger.info('Exiting now!')

if __name__ == '__main__':
    options, args = getopts.getopt(
        version='%prog ' + __version__,
        description=getopts.get_description(),
        epilog=getopts.get_gpl3_text()
    )

    logging.basicConfig(level=options.loglevel, format=BASE_FORMAT_STDOUT)
    root_logger = logging.getLogger('')

    if options.foreground is False:
        daemonize(cwd='/')

    root_logger.setLevel(options.loglevel)
    syslog_logger = SysLogHandler('/dev/log', facility=SysLogHandler.LOG_CRON)
    syslog_logger.setLevel(options.loglevel)
    syslog_formatter = logging.Formatter(BASE_FORMAT_SYSLOG)
    syslog_logger.setFormatter(syslog_formatter)
    root_logger.addHandler(syslog_logger)
    main = Main(sys.argv[0], options, SendNscaWorker, MassivePassiveScheduler)
    signal.signal(signal.SIGTERM, main.shutdown)
    signal.signal(signal.SIGINT, main.shutdown)
    signal.signal(signal.SIGHUP, main.config_reload)
    main.start()
    sys.exit(0)


# vim: tabstop=8 expandtab shiftwidth=4 softtabstop=4
